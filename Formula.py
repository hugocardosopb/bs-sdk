"""
Module: HelenFramework.HelenUtils.Formula
Dumped: 2025-12-16T22:17:09.762840
Generated by SDK Dumper
"""

# module: HelenFramework.HelenUtils.Formula

# Imports
import MType
import cc
import random
import six2

# Variables
COMPONENT = 'Client'
DEG_2_RAD = 0.017453292519943295
EPS = 1e-05
GRAVITY_ACCELERATION = 9.8
QUAT_EPS = 1e-06
RAD_2_DEG = 57.29577951308232
TICK_INTERVAL = 0.0333
acos = <built-in function acos>
asin = <built-in function asin>
atan = <built-in function atan>
atan2 = <built-in function atan2>
ceil = <built-in function ceil>
cos = <built-in function cos>
degrees = <built-in function degrees>
exp = <built-in function exp>
fabs = <built-in function fabs>
floor = <built-in function floor>
logger = <Logger Formula (DEBUG)>
pi = 3.141592653589793
pow = <built-in function pow>
radians = <built-in function radians>
sin = <built-in function sin>
sqrt = <built-in function sqrt>
tan = <built-in function tan>

# Classes
class DataManager(Singleton):
    eqs_consts = <HelenUtils.cached_property.cached_property object at 0x0000018EA3A29B90>

    def Destroy(): ...

    def OnDestroy(self): ...

    def _get_data_from_module(self, name): ...

    def before_reloaded(self): ...

    def get(self, name, default=None): ...

    def init(self): ...

    def instance(*args, **kwargs) -> ~T_SINGLETON_INST: ...

    def isInited(): ...

    def is_destroyed(): ...

    def set_data_path(self, directory): ...

class LogManager:
    asyncwrite = False
    created_modules = {'ClientEnv', 'ServerUtil', 'Preload', 'bhttp_client.BHttpClient', 'Entity', 'Avatar', 'AsioServerProxy', 'PlayerAvatar', 'Model', 'BiologicalRay', 'Doll', 'RpcIndexer', 'Space', 'PlayerEntity', 'asynctimer', 'GateClient', 'mobilerpc.SimpleAsyncBHTTPClient', 'ClientEntity', 'ReplayDummy', 'server.EntityManager', 'BigHeadCalculationDoll', 'Pubsub', 'ClientAreaEntity', 'Account', 'CombatItemEntity', 'SwordSpirit', 'ModelCache', 'SpectatorDecorator', 'AvatarEntity', 'RPGMissile', 'Formula', 'ClientSpace', 'DollLike', 'CalculationDoll', 'server.EntityFactory'}
    custom_handler = None
    log_handle = 'stream'
    log_level = 10
    log_tag = ''
    run_tag = ''
    sa_log_tag = ''
    sys_logger = None

    def _create_handler(logger): ...

    def get_logger(moduleName): ...

    def get_sa_logger(): ...

    def run_message(message): ...

    def set_asyncwrite(asyncwrite): ...

    def set_custom_handler(handler): ...

    def set_log_handle(handle): ...

    def set_log_level(lv): ...

    def set_log_tag(log_tag): ...

    def set_run_tag(run_tag): ...

    def set_sa_log_tag(tag): ...


# Functions
def _angle_to_sphere_surface(center, radius, position, n_direction): ...
def abs_diff_radians(start, end): ...
def accumulated_equal_ratio(init_v, k, num): ...
def add(p1, p2): ...
def add2d(p0, p1): ...
def add3d(p0, p1): ...
def add_four_v(p1, p2, p3, p4): ...
def add_three_v(p1, p2, p3): ...
def addm(*p): ...
def adjust_dist(dst, src, max_dist): ...
def angle(v1, v2, radian=True): ...
def angle_3d(v1, v2): ...
def arc_sin(l, h): ...
def average_p(p0, p1): ...
def between(value, a, b): ...
def choice_in_round(radius, min_radius=0): ...
def clamp(p, p_min, p_max): ...
def clamp_float(v, v_min, v_max): ...
def clamp_vector(v, max_length): ...
def closest_point_on_seg(p, a, b): ...
def cross2d(p0, p1): ...
def cross3d(v0, v1): ...
def cross_point(p1, p2, v): ...
def damp(current, target, velocity, time_step, spring_constant=5): ...
def dcmp(value, eps=1e-05): ...
def degree_to_radian(d): ...
def dir_and_len(v_from, v_to): ...
def distance(p0, p1): ...
def distance_2d(p0, p1): ...
def distance_2d_custom(x0, z0, x1, z1): ...
def distance_2d_sqr(p0, p1): ...
def distance_cube(p0, p1): ...
def distance_manhattan(p0, p1): ...
def distance_point_to_line(p, p0, p1): ...
def distance_point_to_seg(p, a, b): ...
def distance_sqr(p0, p1): ...
def div(p, val): ...
def dot(v0, v1): ...
def dot2d(p0, p1): ...
def eular_angle_to_matrix(pitch, yaw, roll): ...
def eular_to_quat(eular): ...
def euler_to_quaternion(pitch, yaw, roll): ...
def get_center_2d(a, b, c): ...
def get_collision_normal_mat(normal_dir, collide_dir): ...
def get_dodge_position(src, dst, max_dist): ...
def get_min_circle_cover_2d(p): ...
def get_point_on_oval(a, b, radian): ...
def get_point_side_of_line(a, b, p): ...
def get_straight_position(length, start_pos, target_pos): ...
def horizontal_coordinate(origin, yaw, x, z): ...
def horizontal_distance(p0, p1): ...
def horizontal_offset(yaw, x, z): ...
def in_range_2d_custom(pos, x, z, rg): ...
def inrange_2d(p0, p1, rg): ...
def inrange_3d(p0, p1, rg): ...
def inter(percent, source, dest): ...
def intersect2d(p, v, q, w): ...
def intersect3d(p1, v1, p2, v2): ...
def inv_lerp(a, b, y): ...
def is_in_box(box_pos, p2, box_height, height): ...
def is_in_cylinder(p1, p2, cylinder_height, height): ...
def is_in_fan(origin, yaw, theta, p): ...
def is_in_hemisphere(p1, p2, radius, height, is_above): ...
def is_in_middle(pa, pb, pc, pm): ...
def is_in_quad(pm, quad): ...
def is_in_rectangle(center, yaw, width, length, point): ...
def is_in_sphere(sphere_center, target_pos, radius, height): ...
def is_intersect_with_sphere(center, radius, position, n_direction): ...
def is_iterable(p): ...
def is_polygon_intersect_seg2d(point_list, p, q): ...
def is_rectangle_overlay_circle(rec_center, b_length, b_width, yaw, center, radius): ...
def is_valid_quat(quat): ...
def is_zero(vec): ...
def is_zero_2d(vec2): ...
def is_zero_3d(vec3): ...
def judge_point_to_seg_in_limit_dis(p0, p1, p2, limit_dis_sqr): ...
def length(p): ...
def lerp(p1, p2, t): ...
def lerp_factor(p, p_min, p_max): ...
def lerp_v(p1, p2, t): ...
def lerp_vector(start, end, t, limit=False): ...
def linear_map(x, x_range, y_range, need_clamp=False): ...
def localpos_to_worldpos(basePos, baseYaw, localPos): ...
def localpos_to_worldpos_by_vec(basePos, vec_toward, localPos): ...
def look_at_yaw(basePos, targetPos): ...
def max2messiah(pos): ...
def minus(p): ...
def minus3d(p0, p1): ...
def move_to(value, end_value, speed, delta_time): ...
def mul(p, val): ...
def normalize(p): ...
def normalize_and_mul(p, coef=1.0): ...
def normalize_and_mul_2d(x, y, coef=1.0): ...
def normalize_sqr(data, n=1): ...
def normalize_yaw(yaw): ...
def offset_vector(v, offset, theta): ...
def parabola_height(t): ...
def quat_mul(q0, q1): ...
def quat_to_eular(quat): ...
def quat_to_tuple(p): ...
def radian_add(x, y): ...
def radian_diff(x, y): ...
def radian_sub(x, y): ...
def radian_to_degree(r): ...
def random2d(center, radius): ...
def random_float(v_min, v_max): ...
def random_guass_with_limit(mu, sigma, limit=None): ...
def random_idx(probs): ...
def random_point_in_circle(radius, min_radius=0): ...
def random_point_in_sector_with_circle(a, b, start_yaw, end_yaw, scale_a=1.0, scale_b=1.0): ...
def random_point_in_sector_with_rect(half_w, half_h, start_yaw, end_yaw, scale_w=1.0, scale_h=1.0): ...
def random_point_in_sphere(r): ...
def random_point_on_sphere(r, min_alpha_deg=-180, max_alpha_deg=180, min_gamma_deg=0, max_gamma_deg=360, reference_vec=None): ...
def random_test(prob): ...
def random_vec(v_base, angle): ...
def reflect(i, n): ...
def remap_val_clamped(fValue, fFromMin, fFromMax, fToMin, fToMax): ...
def rotate2d(x0, y0, x1, y1, angle, flag=False): ...
def rotate_angle(v1, v2): ...
def rotate_by_yaw(x, z, radian): ...
def round_vec(v, n): ...
def sample_points(n): ...
def scale(p, val): ...
def seg_intersect2d(a, b, c, d): ...
def sign(value): ...
def simple_sigmoid_map(val, upper_limit, lower_limit): ...
def slerp(q0, q1, t): ...
def slerp_v(start, end, t, limit=False): ...
def slerp_vector(start, end, t, limit=False): ...
def smooth_damp(current, target, current_velocity, smooth_time, maxSpeed, deltaTime): ...
def snap_to_zero(value, eps=0.0001): ...
def sphere_surface_point(center, radius, direction): ...
def substract(p0, p1): ...
def substract2d(p0, p1): ...
def substract3d(p0, p1): ...
def to_tuple(p): ...
def transform_bb(m, local_bound): ...
def transform_p(m, pos): ...
def transform_v(m, v): ...
def unit_vector_2d(vec2): ...
def v2_to_tuple(p): ...
def v3_to_tuple(p): ...
def v4_to_tuple(p): ...
def variance(val_list): ...
def vector_to_pitch(vec): ...
def vector_to_yaw(vec): ...
def vertical_vector_2d(vec2): ...
def waypoint(frm, to, step): ...
def weighted_choice(choices): ...
def y_look_at(front, up=(0, 1, 0)): ...
def yaw_diff(yaw1, yaw2): ...
def yaw_pitch_to_vector(yaw, pitch): ...
def yaw_to_quaternion(yaw): ...
def yaw_to_vector(yaw): ...
def yaw_to_vector2d(yaw): ...
def yaw_vector_2d(yaw, v): ...
def yaw_vector_3d(yaw, v): ...

